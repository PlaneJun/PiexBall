# 一、保护模式

# 1、保护模式简介

CPU分有：`实模式`、`保护模式`、`虚拟8086`模式，大多数操作系统都运行在保护模式下。

保护模式主要是用来保护寄存器、数据结构、指令，实际上也就是保护寄存器，因为cpu的数据都存放在寄存器中。

保护模式的特点：段和页。

- 实模式：16位系统DOS，访问的都是物理地址，不安全。
- 保护模式：将物理地址隔阂后，使用一种线性的虚拟地址来访问，相对实模式来说比较安全。并用段和页的特点来维护虚拟地址。

保护模式具体资料可以在 Intel白皮书第三卷 中查看。

# 2、段寄存器

## 2.1 段选择子

CPU一共有八个段寄存器：ES CS SS DS FS GS LDTR TR ，OD可见前6个，但GS段寄存器windows并未使用（32位下）。

![Untitled.jpeg](%E4%B8%80%E3%80%81%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%209125e0c3a44a4d1c9a4f48e1572cac4b/Untitled.jpeg)

如果运行在实模式下，则只有前四个有用。

如果是64位，则使用GS而不是FS。

当执行下列汇编代码时

```nasm
mov [0x12345678],eax
```

实际上cpu所“看到的”代码如下：

```nasm
mov dword ptr ds:[0x12345678],eax
//ds.base+0x12345678
//cs.base+0x12345678
//ss.base+0x12345678
```

💡 ds段寄存器通常时用来存放要访问数据的段地址。cs段寄存器表示要执行的代码。ss段寄存器表示堆栈的段地址。[…]则表示一个内存单元，比如ds:[1],cs:[1],ss:[1]。——王爽《汇编语言》

段寄存器结构： 共96位， 16位可见，80位不可见。

![Untitled 1.jpeg](%E4%B8%80%E3%80%81%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%209125e0c3a44a4d1c9a4f48e1572cac4b/Untitled_1.jpeg)

```c
struct SegMen{    WORD Selector;//16位    WORD Attributes;//16位    DWORD Base;//32位    DWORD Limit;//32位};
```

读段寄存器指令：mov ax,es **只能读16位**（可见部分）

写段寄存器指令：mov ds,ax **写了96位的**。

段寄存器可以用mov指令读写，但是LDTR和TR除外。

加载段描述符至段寄存器的指令共有三种：

- mov ss,ax 使用mov指令
- **les lss lds lfs lgs**修改对应的段寄存器
- cs不能通过上述指令改变，否则会导致EIP的改变，必须保证cs与eip一起改。后文会讲解如何修改CS并在需要时提升权限。

其中选择子(Selector)有如下结构：

![Untitled.png](%E4%B8%80%E3%80%81%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%209125e0c3a44a4d1c9a4f48e1572cac4b/Untitled.png)

打开OD，随便加载一个程序可以看到段寄存器对应的选择子。

![Untitled 2.jpeg](%E4%B8%80%E3%80%81%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%209125e0c3a44a4d1c9a4f48e1572cac4b/Untitled_2.jpeg)

以fs的选择子为例进行解析：

```c
fs=0x0053 => 0000 0000 0101 0011
由于前面两个字节为0，因此单独拿后面两个字节讲解。
0101 0011
根据上面给出的Selector表可以对这两个字节划分。
01010 0 11

值     |    含义
- ------------------------------------------------
01010  |    欲查表的索引号,此处为十进制5
0      |    欲查哪一块表;0->GDT 1->LDT
11     |    哪一环的权限(RPL),此处为十进制3,因此为3环
根据公式 addr = GDT + 8 * index计算后可得到fs的段描述符
addr = 0xfffff88004590000 + 8 * 5 = 0xfffff88004590028

2: kd> dq fffff88004590028
fffff880`04590028  **00cff300`0000ffff** 0020fb00`00000000
fffff880`04590038  00000000`00000000 04008b58`f0000067
fffff880`04590048  00000000`fffff880 ff40f3fd`f000bc00
fffff880`04590058  00000000`00000000 00cf9a00`0000ffff
fffff880`04590068  00000000`00000000 00000000`00000000
fffff880`04590078  00000000`00000000 00000000`00000000
fffff880`04590088  00000000`00000000 00000000`00000000
fffff880`04590098  00000000`00000000 00000000`00000000
```

> GDT：全局描述表（Global Description Table），在操作系统加载完毕后就存在的一快内存。实际上就是一个数组，每一个元素就是一个描述符，多个组合一起就构成了全局描述符表。而每一个描述符共64位，包含了以下的这些信息：段基址、段长度、属性。段寄存器通过解析选择子后得到索引后在GDT中跳转获取对应描述符。
> 

> LDT：局部描述表（Local Description Table），与GDT功能一致，但不能单独存在，只能嵌套在GDT中。
> 
- **windbg获取GDT**

GDT可以使用windbg的命令可以查看gdt表的地址：

```c
gdtr寄存器（windbg伪寄存器，是windbg通过sgdt lgdt指令获取的，为了方便用户，才模拟了一个寄存器叫gdtr，实际是没有这个寄存器的） :
存两个值，一个是GDT表在哪里，一个是GDT表有多大   48位  有32位存储在哪里，16位存储大小
r gdtr  r查看gdtr寄存器的地址
r gdtl  r查看gdtr寄存器的大小  都查gdtr
dd  xxxx       4字节查看内存
dq  XXXX       8字节查看内存
dq  xxxx Lnum    查看固定数量元素的内存
```

![Untitled 3.jpeg](%E4%B8%80%E3%80%81%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%209125e0c3a44a4d1c9a4f48e1572cac4b/Untitled_3.jpeg)

- **r3代码获取GDT**

通过指令sgdt获取。其中共获取到6个字节,前两个字节位gdt寄存器的大小,后面四个字节为gdt的地址。

![Untitled 1.png](%E4%B8%80%E3%80%81%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%209125e0c3a44a4d1c9a4f48e1572cac4b/Untitled_1.png)

```c
#include "stdafx.h"
#include<stdlib.h>

int _tmain(int argc, _TCHAR* argv[])
{
	unsigned char var[6]={0};
	_asm{
		sgdt var
	}
	printf("%x,%x\n",*(unsigned int*)&var[2],*(unsigned short*)&var[0]);
	return 0;
}
```

![Untitled 2.png](%E4%B8%80%E3%80%81%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%209125e0c3a44a4d1c9a4f48e1572cac4b/Untitled_2.png)

## 2.2 段描述符

段描述符有如下结构：

![Untitled 3.png](%E4%B8%80%E3%80%81%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%209125e0c3a44a4d1c9a4f48e1572cac4b/Untitled_3.png)

将`0x00cff300`0000ffff`进行拆分可得到如下

```c
base:0x00000000
attr:0x0cf3(前面的0是补齐2字节)
limit:0xfffff(前面的0是补齐4字节)

attr的属性又可以细分如下：
0xc = 1100
----------------------------
G:1;1->limit以4k对齐,limit = ( limit + 1 ) * 4096 - 1    0->字节对齐,limit = limit
D/B:1
0:0
AVL:0

0xf3 = 1111 0011
-----------------------------
P:1
DPL:11
S:1
Type:0011(3)
```

- **G位**
    
    段对齐粒度。 也就是决定了Limit大小的一个位。
    
    在上文填充段寄存器隐藏部分时，Limit在描述符中只有5个16进制位表示，剩下的3个16进制位就需要看G位。
    
    当G为0时，整个段将以字节对齐，Limit大小单位为字节，所以精确到1。Limit直接就是段长。段寄存器中的Limit高位补0。
    
    当G为1时，整个段将以4KB对齐，Limit大小单位为4KB，所以段的末尾处一定是以FFF结尾。段寄存器中的Limit低位补FFF。
    
- **D/B位**
    
    **=0**表示是16位的单位,**=1**表示32位的单位。
    
    如果是代码段的描述符,那么称为D;如果是数据段的描述符,称为B。
    
    大段或者小段，分为三种情况：
    
    **对CS段来说：**
    
    为1时，默认为32位寻址。
    
    为0时，默认为16位寻址。
    
    前缀67改变寻址方式。
    
    **对SS段来说：**
    
    为1时，隐式堆栈访问指令（PUS H POP CALL RETN等）修改的是32位寄存器ESP
    
    为0时，隐式堆栈访问指令（PUSH POP CALL RETN等）修改的是16位寄存器SP
    
    对于向下扩展的数据段：
    
    为1时，段上限大小为4GB(2的32次方)。 为0时 段上限大小为64KB(2的16次方)。
    
    ![Untitled 4.png](%E4%B8%80%E3%80%81%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%209125e0c3a44a4d1c9a4f48e1572cac4b/Untitled_4.png)
    
- P位
    
    有效位 1：描述符有效 0：描述符无效
    
    当描述符无效时，任何尝试加载该描述符、访问该描述符对应的段间地址都会报错。
    
- **DPL位**
    
    能访问段描述符的权限。
    
    💡 DPL、CPL、RPL的区别在于，DPL是段描述符的权限,属于固定且默认。RPL是段寄存器的权限，CRL同样是段寄存器的权限,但与RPL区别就是CRL指的是当前代码执行的时候所访问段寄存器的权限。 mov eax,dword ptr ds:[0x12345678] ;此时CRL指的是ds寄存器的权限,其他寄存器的权限称为RPL. **总之,用哪个段寄存器,那个寄存器的权限就叫做CRL。常规情况下,代码的每次执行都会用到CS和SS段寄存去,所以这两个段寄存器称为CRL,其他的叫做RPL。**
    
- S位
    
    描述符类型位。 为0时，是**系统段描述符**。 为1时，是**代码或数据段描述符**。具体类型需要搭配type属性来判断。
    
- Type位
    
    由S位决定了具体是代码段还是数据段描述符
    
    - **当S=1,type表示为数据段的描述**
    
    > 数据段： A位：数据段是否被访问过位，访问过为1，未访问过为0  段描述符是否被加载过 W位：数据段是否可写位，可写为1，不可写为0 E位：向下扩展位，0向上扩展：段寄存器.base+limit区域可访问。1向下扩展：除了base+limit以外的部分可访问。
    > 
    
    > 代码段： A位：代码段是否被访问过位，访问过为1，未访问过为0  段描述符是否被加载过 R位：代码段是否可读位，可读为1，不可读为0。(但R位为0,代码段照样可以读) C位：一致位。1：一致代码段(0环的函数在3环可以调用)。   0：非一致代码段(各调各的)
    > 
    
    ![Untitled 5.png](%E4%B8%80%E3%80%81%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%209125e0c3a44a4d1c9a4f48e1572cac4b/Untitled_5.png)
    
    # 针对E位的理解与实验：
    
    ![左边为向上扩展,右边为向下扩展。红色代表可以访问,绿色不可访问](%E4%B8%80%E3%80%81%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%209125e0c3a44a4d1c9a4f48e1572cac4b/Untitled_6.png)
    
    左边为向上扩展,右边为向下扩展。红色代表可以访问,绿色不可访问
    
    `Tip:段描述符有没有4G,首先是看E位的拓展方向,其次是看Base和limit之间的大小。`
    
    首先构造一条段描述符.
    
    ```bash
    00cff700`0000ffff
    
    base:00000000 
    attr:0cf7 
    limit:fffff   ;由于G位是1所以这里实际为(0xfffff+1) * 0x1000 - 1 = 0xFFFFFFFF
    
    E位:0111,**向下扩展**
    ```
    
    通过windbg的`e[b|d|D|f|p|q|w] address [Values]`指令可以修改GDT中保存的段描述符。修改8003f090(GDTR = 8003f000),然后输出gdt查看前20个描述表,`dq address l20`。(注意是小写L,不是数字1)。
    
    ![Untitled 7.png](%E4%B8%80%E3%80%81%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%209125e0c3a44a4d1c9a4f48e1572cac4b/Untitled_7.png)
    
    ## 测试代码1
    
    ---
    
    ```c
    //code1:
    #include "stdafx.h"
    unsigned char var = 0; //全局变量
    int _tmain(int argc, _TCHAR* argv[])
    {
    	_asm{
    		mov ax,0x93 //10010 011 -> index = 18 * 8 = 144 (0x90)
    		mov ds,ax
    		mov dword ptr ds:[var],0x20
    	}
    	printf("%X\n",var);
    	return 0;
    }
    ```
    
    运行出错。
    
    ![Untitled 8.png](%E4%B8%80%E3%80%81%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%209125e0c3a44a4d1c9a4f48e1572cac4b/Untitled_8.png)
    
    **分析：**异常断在了赋值var的地方。首先在描述符中attr为0x0cf7,Type=0111表示为向下扩展、可读写、已访问。根据上图可知,如果E位为向下扩展,则base+limit这段区域是无法访问的。回到代码中可以看到变量var为全局变量,通常情况下数据都是存放在数据段,即**ds段**中,因此变量var的虚拟地址存放在base+limit中,此时因为无法访问该区域,因此在写数据时发生了错误。**修复方法为将E位修改为向上扩展(E=0)，或者将limit修改为一个小范围值,使得其他区域的内存可以访问(在demo2实现)。**
    
    ![Untitled 9.png](%E4%B8%80%E3%80%81%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%209125e0c3a44a4d1c9a4f48e1572cac4b/Untitled_9.png)
    
    ![Untitled 10.png](%E4%B8%80%E3%80%81%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%209125e0c3a44a4d1c9a4f48e1572cac4b/Untitled_10.png)
    
    实验成功!
    
    ## 测试代码2
    
    ---
    
    首先将0x8003f090修改回0x00cff700`0000ffff。
    
    ```c
    #include "stdafx.h"
    int _tmain(int argc, _TCHAR* argv[])
    {
    	unsigned char var = 0; //局部变量
    	_asm{
    		mov ax,0x93
    		mov ds,ax
    		mov dword ptr ds:[var],0x20
    	}
    	printf("%X\n",var);
    	return 0;
    }
    ```
    
    运行同样报错。
    
    ![Untitled 11.png](%E4%B8%80%E3%80%81%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%209125e0c3a44a4d1c9a4f48e1572cac4b/Untitled_11.png)
    
    **分析：**需要注意的是中断打在了printf上,说明我们上边的ASM代码没问题!那么一个新问题来了,为什么demo1中中断打在了var赋值上?虽然我们显式使用了ds段来描述变量var,但仍存在一个问题,**变量var属于堆栈地址**,所以实际上`mov dword ptr ds:[var]`被编译器翻译成了`mov dword ptr ss:[var]`
    
    ![Untitled 12.png](%E4%B8%80%E3%80%81%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%209125e0c3a44a4d1c9a4f48e1572cac4b/Untitled_12.png)
    
    ![Untitled 13.png](%E4%B8%80%E3%80%81%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%209125e0c3a44a4d1c9a4f48e1572cac4b/Untitled_13.png)
    
    因为我们没有修改ss段,所以上面对ss段的操作没问题。根据单步执行,可以发现中断的位置是printf函数。
    
    ![Untitled 14.png](%E4%B8%80%E3%80%81%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%209125e0c3a44a4d1c9a4f48e1572cac4b/Untitled_14.png)
    
    根据我们构造的描述符可知,base=0,limit的范围为0xFFFFFFFF,然后又属于向下扩展,所以0x0-0xFFFFFFFF的区域无法访问,printf中必然有用到ds段的数据,但这些数据有没有访问权限,因此访问中断了。**修复方法为将limit设置为一个很小的范围,这样其他的区域就可以访问了。比如0x1FFF。(00c0f700`00000001)**
    
    ![Untitled 15.png](%E4%B8%80%E3%80%81%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%209125e0c3a44a4d1c9a4f48e1572cac4b/Untitled_15.png)
    
    ![Untitled 16.png](%E4%B8%80%E3%80%81%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%209125e0c3a44a4d1c9a4f48e1572cac4b/Untitled_16.png)
    
    实验完成!
    
    - **当S=0,type表示为系统描述**
        
        (小于8是16位的系统描述,大于8是32位)
        
        ![Untitled 17.png](%E4%B8%80%E3%80%81%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%209125e0c3a44a4d1c9a4f48e1572cac4b/Untitled_17.png)
        

使用windbg的`dg segment`命令可以快速查看段寄存器对应的段描述符。

![Untitled 4.jpeg](%E4%B8%80%E3%80%81%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%209125e0c3a44a4d1c9a4f48e1572cac4b/Untitled_4.jpeg)

![Untitled 5.jpeg](%E4%B8%80%E3%80%81%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%209125e0c3a44a4d1c9a4f48e1572cac4b/Untitled_5.jpeg)

## 2.3 段寄存器证明

读的时候只能读到16位(选择子)，但写的时候却写入了96位。如何证明剩下的80位是否存在？

![Untitled 6.jpeg](%E4%B8%80%E3%80%81%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%209125e0c3a44a4d1c9a4f48e1572cac4b/Untitled_6.jpeg)

- **Attribute探测**

```c
int main(int argc,char* argv[]){
	int var = 0;
	__asm{
		mov ax,ss                //ss可读可写
		mov ds,ax                //ds可读可写
		mov dword ptr ds:[var],eax        //ds此时为ss，不报错，说明两个段寄存器权限相同
	}
}
```

```c
int main(int argc,char* argv[]){
	int var = 0;
		__asm{
			mov ax,cs            //cs可读可执行不可写
			mov ds,ax            //ds可读可写
			mov dword ptr ds:[var],eax        //ds此时为cs，写入时报错，说明Attribute属性存在
	}
}
```

- **Base探测**

```c
int main(int argc,char* argv[]){
	int var = 0;
	__asm{
		mov ax,fs            //fs 的 base为TEB  用ds编译不过去
		mov gs,ax            //gs 的 base为0
		mov eax,gs:[0]        //gs此时为fs，写入不出错，说明Base属性存在  fs.base+0
		mov dword ptr gs:[var],eax
	}
}
```

- **Limit探测**

```c
int main(int argc,char* argv[]){
	int var = 0;
	__asm{
		mov ax,fs            //fs 的 base为TEB  用ds编译不过去
		mov gs,ax            //gs 的 base为0
		mov eax,gs:[0x1000]        //写入出错，超过了fs的limit，说明Limit属性存在 fs.base+0x1000
		//mov eax,ds:[0x7FFDF000+0x1000]  不报错
		mov dword ptr gs:[var],eax
	}
}
```

## 2.4 段寄存器权限

利用les指令修改es段寄存器，代码如下

```c
#include "stdafx.h"
#include<stdlib.h>
int _tmain(int argc, _TCHAR* argv[])
{
	//0x12345678 = EAX
	//0x001b = ES
	unsigned char var[6]={0x78,0x56,0x34,0x12,0x1b,00};
	_asm{
		les eax,fword ptr ds:[var] //因为是写入6字节,所以需要显式fword赋值
	}
	/*
	_asm{
		mov ax,0x1b
		mov es,ax
	}
	/*
	return 0;
}
```

运行正常，效果如下：

![Untitled 7.jpeg](%E4%B8%80%E3%80%81%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%209125e0c3a44a4d1c9a4f48e1572cac4b/Untitled_7.jpeg)

上面代码中写入ES的值位0x001b,对应二进制位`0000 0000 0001 1011`,按照选择子结构划分后得到`0011 0 11`,末尾两位十进制为3,即CRL为3环权限。当前实验环境同样为3环，因此程序正常。此时将代码的0x001b修改为0x0010,重新运行后报错。

![Untitled 8.jpeg](%E4%B8%80%E3%80%81%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%209125e0c3a44a4d1c9a4f48e1572cac4b/Untitled_8.jpeg)

因为0x0010按照选择子结构划分后,得到的CRL为0,属于0环权限。CPU由于保护机制,不允许3环程序访问0环程序的数据，因此程序发生错误。在修改段寄存器时需要遵守**CRL ≤ DRL。**

---

> mov ds,ax
> 

```c
;执行步骤
;1、检查CS.CPL>=CS.DPL(是否有权限执行,无权限则中断)
;2、检查ds是否等于ax,如果相等则不做任何处理。否则接着第三步
;3、检查ax的DS.RPL>=DS.DPL(是否有权限执行,无权限则中断)
;4、赋值成功,刷新缓存。
```

## Demo1

```c
#include "stdafx.h"
int _tmain(int argc, _TCHAR* argv[])
{
	_asm{
		mov ax,0x20 //0x20表示为0环权限,对应描述符为00cff300`0000ffff -> DPL=3
		mov ds,ax
	}
	return 0;
};执行步骤
;1、检查CS.CPL>=CS.DPL(是否有权限执行,无权限则中断)
;2、检查ds是否等于ax,如果相等则不做任何处理。否则接着第三步
;3、检查ax的DS.RPL>=DS.DPL(是否有权限执行,无权限则中断)
;4、赋值成功,刷新缓存。
```

运行后没问题。因为CS.CPL≥CS.DPL,DS.RPL≥DS.DPL

## Demo2

首先修改`0x8003f090`为`0x00cf9300`0000ffff`即0环权限。

![Untitled 9.jpeg](%E4%B8%80%E3%80%81%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%209125e0c3a44a4d1c9a4f48e1572cac4b/Untitled_9.jpeg)

```c
#include "stdafx.h"
int _tmain(int argc, _TCHAR* argv[])
{
	_asm{
		mov ax,0x93 //0x93表示为3环权限,对应描述符00cf9300`0000ffff -> DPL=0
		mov ds,ax
	}
	return 0;
}
```

运行后中断。

![Untitled 10.jpeg](%E4%B8%80%E3%80%81%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%209125e0c3a44a4d1c9a4f48e1572cac4b/Untitled_10.jpeg)

因为此时DS.RLP<DS.DPL(3环访问0环数据,不合法)。将代码进行修改如下:

```c
#include "stdafx.h"
int _tmain(int argc, _TCHAR* argv[])
{
	_asm{
	mov ax,0x90 //0x90表示为0环权限,对应描述符00cf9300`0000ffff -> DPL=0
	mov ds,ax
	}
	return 0;
}
```

运行后依然报错。

![Untitled 11.jpeg](%E4%B8%80%E3%80%81%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%209125e0c3a44a4d1c9a4f48e1572cac4b/Untitled_11.jpeg)

虽然DS.RPL≥DS.DPL,但是CS.CPL<DS.RPL,导致3环空间无法访问0环空间,所以中断了。(理论上,把CS、SS、DS的DPL、CPL、RPL都改成0环,就能直接在0环搞事,但是CS和SS不好改,需要特权指令。)

- **总结:CS.CPL ≥ CS.DPL && DS.RPL ≥ DS.DPL && CS.CPL ≥ DS.RPL最终得到**
- **CS.CPL≥CS.DPL && CS.CPL≥DS.DPL**

💡 由于CS是代码段寄存器,代码的执行必定是需要用到堆栈,因此CS和SS的CPL、DPL、RPL必须一致。